Integer[][] dp is faster than int[][] dp in case there are lots of 0s stored as answer to subproblems.
Use null instead of 0 to check conditions(if).


int index = Collections.binarySearch(list, nums[i]);
if (index < 0) {
	index = -(index + 1);
}
int oldVal = list.set(index, nums[i]);
int start = 0;
int end = list.size() - 1;

while (start <= end) {
	int mid = start + (end - start) / 2;
	if (nums[i] <= list.get(mid)) {
		end = mid - 1;
	} else {
		start = mid + 1;
	}
}
int oldVal = list.set(start, nums[i]);


To sort an List containing int[] based on 1st index.
List<int[]> list = new ArrayList<>();
list.sort(Compartor.comparingInt(a -> a[0]));
Example: 
	List<int[]> spellsList = new ArrayList<>();
	for (int i = 0; i < n; i++) {
		spellsList.add(new int[] { spells[i], i });
	}
	spellsList.sort(Comparator.comparingInt(a -> a[0]));


Sorting a 2D array with a[0].length = 2 can be done in O(n*logn) time
If we want to sort the array based on index=0 in ascending order and then for index=1 in descending order
Arrays.sort(envelopes, (a, b) -> a[0] - b[0] != 0 ? a[0] - b[0] : b[1] - a[1]);
Arrays.sort(envelopes, Comparator.comparingInt((int[] a) -> a[0]).thenComparing((a, b) -> Integer.compare(b[1], a[1])));


BFS
An algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all
the nodes at the present level(say l) are explored before moving on to the nodes at the next levt(l+1),
where a level's number is the distance from a starting node. It's implemented with a queue.

	 A breadth-first search algo can be used to find the shortest path in an
	 unweighted graph. For BFS, the 1st time a node is reached during the
	 traversal, it was reached in minimum possible steps from the source. The path
	 used in BFS traversal always has the least number of edges. The BFS algorithm
	 does a level-wise iteration which finds all paths that 1 edge away from
	 source node, followed by all paths that are 2 edges away from the source
	 node, and so on. This allows BFS to find the shortest path from source to
	 other nodes.
	 
In BFS and DFS we don't need to keep track of the nodes traversed when the structure being 
traversed over is a directed tree without any cycles. Hence, a node is never visited twice.


Graph terminologies:
Child: A node that is 1 edge away further away from a given node in a rooted tree. 
The given node for the children node is called the parent.
Descendants: The descendants of a node are children, children of children, and so on.
Subtree: A subtree of a node T is a tree S consisting of node T and all of its descendants
in T. The subtree of root node is entire tree.


Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, graph = [[1,2],[3],[3],[]]
graph[i][j] == i, means there is a self loop.

Backtracking algorithm
Backtracking is a general algorithm that incrementally builds candidates to the solutions,
and abandons a candidate ("backtrack") as soon as it determines that the candidate cannot
lead to a valid solution.
When there is path exploration we can apply Backtracking algorithm.


